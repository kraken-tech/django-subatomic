{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Subatomic docs","text":""},{"location":"why/","title":"Why","text":""},{"location":"why/#djangos-atomic","title":"Django's Atomic","text":"<p>Django's <code>atomic</code> ensures database changes are committed together-or-not-at-all. It creates a savepoint or a transaction depending on two factors:</p> <ul> <li>The arguments passed to it (<code>durable</code> and <code>savepoint</code>).</li> <li>If a database transaction is already open.</li> </ul> <p>Specifically, the Behaviours which <code>atomic</code> exhibits are:</p> <code>durable=False</code> (default) <code>durable=True</code> <code>savepoint=True</code> (default) A. Begin a transaction if needed. Creates a savepoint if already in a transaction. B. Begin a transaction, or throw an error if one is already open. Never creates a savepoint. (The <code>savepoint</code> flag is ignored.) <code>savepoint=False</code> C. Begin a transaction if needed. Never creates a savepoint. D. Same as B. <p>Uses of <code>atomic</code> fall into three broad Categories:</p> <ol> <li>Create a transaction to wrap multiple changes.</li> <li>Create a savepoint so we can roll back to in order to continue with a transaction after failure.</li> <li>Changes to be committed atomically, but not specific about where the transaction is created, as long as there is one.</li> </ol>"},{"location":"why/#problems","title":"Problems","text":"<p>Django's atomic creates many savepoints that are never used. There are a couple of main causes:</p> <ol> <li>Savepoints are created with decorators (<code>@atomic</code>).</li> <li> <p><code>atomic</code> creates savepoints by default. The default arguments (Behaviour A) are an attractive nuisance because they make us create savepoints when we don't need them.</p> <p>\u2026 if you have two ways to accomplish a task and one is a simple way that looks like the right thing but is subtly wrong, and the other is correct but more complicated, the majority of people will end up doing the wrong thing. \u2014 Attractive nuisances in software design - Paul Ganssle</p> </li> <li> <p>We have no easy way to indicate the creation of a savepoint that doesn't have the potential to create a transaction instead. The only tool we have to create a savepoint is Behaviour A, which can create a transaction.</p> </li> </ol>"},{"location":"why/#what-subatomic-implements","title":"What Subatomic implements","text":"<ul> <li><code>transaction()</code>. Begin a transaction, or throw an error if a transaction is already open. Like <code>atomic(durable=True)</code>, but with added after-commit callback support in tests.</li> <li><code>savepoint()</code>. Create a savepoint, or throw an error if we're not already in a transaction. This is not in the table of Behaviours (the closest we have is Behaviour A, but that can create transactions).</li> <li><code>transaction_if_not_already()</code>. Begin a transaction if we're not already in one. Just like Behaviour C. This has a bit of a clunky name. This is deliberate, and reflects that it's a bit of a clunky thing to do. To be used with caution because the creation of a transaction is implicit. For a stricter alternative, see <code>transaction_required()</code> below.</li> <li><code>transaction_required()</code>. Throw an error if we're not already in a transaction. Does not create savepoints or transactions.</li> </ul>"},{"location":"reference/django_subatomic/","title":"django_subatomic","text":""},{"location":"reference/django_subatomic/#django_subatomic","title":"django_subatomic","text":""},{"location":"reference/django_subatomic/db/","title":"db","text":""},{"location":"reference/django_subatomic/db/#django_subatomic.db","title":"django_subatomic.db","text":""},{"location":"reference/django_subatomic/db/#django_subatomic.db.transaction","title":"transaction","text":"<pre><code>transaction(*, using: str | None = None) -&gt; Iterator[None]\n</code></pre> <p>Create a database transaction.</p> <p>Nested calls are not allowed because SQL does not support nested transactions. Consider this like Django's <code>atomic(durable=True)</code>, but with added after-commit callback support in tests.</p> <p>This wraps Django's 'atomic' function.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if we call this from inside another existing transaction.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>@contextlib.contextmanager\ndef transaction(*, using: str | None = None) -&gt; Iterator[None]:\n    \"\"\"\n    Create a database transaction.\n\n    Nested calls are not allowed because SQL does not support nested transactions.\n    Consider this like Django's `atomic(durable=True)`, but with added after-commit callback support in tests.\n\n    This wraps Django's 'atomic' function.\n\n    Raises:\n        RuntimeError: if we call this from inside another existing transaction.\n    \"\"\"\n    # Note that `savepoint=False` is not required here because\n    # the `savepoint` flag is ignored when `durable` is `True`.\n    with (\n        _execute_on_commit_callbacks_in_tests(using),\n        django_transaction.atomic(using=using, durable=True),\n    ):\n        yield\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.transaction_if_not_already","title":"transaction_if_not_already","text":"<pre><code>transaction_if_not_already(*, using: str | None = None) -&gt; Iterator[None]\n</code></pre> <p>Create a transaction if one isn't already open.</p> <p>Use of this hints at code which lacks control over the state it's called in.</p> <p>Suggested alternatives:</p> <ul> <li> <p>In functions which should not control transactions, use <code>transaction_required</code>.   This ensures they are handled by the caller.</p> </li> <li> <p>In functions which can unambiguously control transactions, use <code>transaction</code>.</p> </li> </ul> Source code in <code>django_subatomic/db.py</code> <pre><code>@contextlib.contextmanager\ndef transaction_if_not_already(*, using: str | None = None) -&gt; Iterator[None]:\n    \"\"\"\n    Create a transaction if one isn't already open.\n\n    Use of this hints at code which lacks control over the state it's called in.\n\n    Suggested alternatives:\n\n    - In functions which should not control transactions, use `transaction_required`.\n      This ensures they are handled by the caller.\n\n    - In functions which can unambiguously control transactions, use `transaction`.\n    \"\"\"\n    # If the innermost atomic block is from a test case, we should create a SAVEPOINT here.\n    # This allows for a rollback when an exception propagates out of this block, and so\n    # better simulates a production transaction behaviour in tests.\n    savepoint = _innermost_atomic_block_wraps_testcase(using=using)\n\n    with (\n        _execute_on_commit_callbacks_in_tests(using),\n        django_transaction.atomic(using=using, savepoint=savepoint),\n    ):\n        yield\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.savepoint","title":"savepoint","text":"<pre><code>savepoint(*, using: str | None = None) -&gt; Generator[None, None, None]\n</code></pre> <p>Create a database savepoint.</p> <p>Must be called inside an active transaction.</p> <p>Tips:</p> <ul> <li>You should only create a savepoint if you may roll back to it before   continuing with your transaction. If your intention is to ensure that   your code is committed atomically, consider using <code>transaction_required</code>   instead.</li> <li>We believe savepoint rollback should be handled where the savepoint is created.   That locality is not possible with a decorator, so this function   deliberately does not work as one.</li> </ul> <p>Raises:</p> Type Description <code>_MissingRequiredTransaction</code> <p>if we are not in a transaction See Note [_MissingRequiredTransaction in tests]</p> Source code in <code>django_subatomic/db.py</code> <pre><code>@_contextmanager_without_decorator\ndef savepoint(*, using: str | None = None) -&gt; Generator[None, None, None]:\n    \"\"\"\n    Create a database savepoint.\n\n    Must be called inside an active transaction.\n\n    Tips:\n\n    - You should only create a savepoint if you may roll back to it before\n      continuing with your transaction. If your intention is to ensure that\n      your code is committed atomically, consider using `transaction_required`\n      instead.\n    - We believe savepoint rollback should be handled where the savepoint is created.\n      That locality is not possible with a decorator, so this function\n      deliberately does not work as one.\n\n    Raises:\n        _MissingRequiredTransaction: if we are not in a transaction\n            See Note [_MissingRequiredTransaction in tests]\n    \"\"\"\n    with (\n        transaction_required(using=using),\n        django_transaction.atomic(using=using),\n    ):\n        yield\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.transaction_required","title":"transaction_required","text":"<pre><code>transaction_required(*, using: str | None = None) -&gt; Iterator[None]\n</code></pre> <p>Make sure that code is always executed in a transaction.</p> <p>Can be used as a decorator or a context manager.</p> <p>We ignore test-suite transactions when checking for a transaction because we don't want to run the risk of allowing code to pass tests but fail in production.</p> <p>See Note [_MissingRequiredTransaction in tests]</p> <p>Raises:</p> Type Description <code>_MissingRequiredTransaction</code> <p>if we are not in a transaction.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>@contextlib.contextmanager\ndef transaction_required(*, using: str | None = None) -&gt; Iterator[None]:\n    \"\"\"\n    Make sure that code is always executed in a transaction.\n\n    Can be used as a decorator or a context manager.\n\n    We ignore test-suite transactions when checking for a transaction\n    because we don't want to run the risk of allowing code to pass tests\n    but fail in production.\n\n    See Note [_MissingRequiredTransaction in tests]\n\n    Raises:\n        _MissingRequiredTransaction: if we are not in a transaction.\n    \"\"\"\n    if using is None:\n        using = django_db.DEFAULT_DB_ALIAS\n\n    if not in_transaction(using=using):\n        raise _MissingRequiredTransaction(database=using)\n    yield\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.durable","title":"durable","text":"<pre><code>durable[**P, R](func: Callable[P, R]) -&gt; Callable[P, R]\n</code></pre> <p>Enforce durability with this decorator.</p> <p>\"Durability\" means that the function's work cannot be rolled back after it completes, and is not to be confused with \"atomicity\" (which is about ensuring that the function either completes all its work or none of it).</p> <p>We enforce this by ensuring that the function is not called within a transaction, and that no transaction is left open when the function completes.</p> <p>Raises:</p> Type Description <code>_UnexpectedOpenTransaction</code> <p>if a transaction is already open when this is called.</p> <code>_UnexpectedDanglingTransaction</code> <p>if a transaction remains open after the decorated function exits. Before raising this exeption, we roll back and end the transaction.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>def durable[**P, R](func: Callable[P, R]) -&gt; Callable[P, R]:\n    \"\"\"\n    Enforce durability with this decorator.\n\n    \"Durability\" means that the function's work cannot be rolled back after it completes,\n    and is not to be confused with \"atomicity\" (which is about ensuring that the function\n    either completes all its work or none of it).\n\n    We enforce this by ensuring that the function is not called within a transaction,\n    and that no transaction is left open when the function completes.\n\n    Raises:\n        _UnexpectedOpenTransaction: if a transaction is already open when this is called.\n        _UnexpectedDanglingTransaction: if a transaction remains open after the decorated\n            function exits. Before raising this exeption, we roll back and end the\n            transaction.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        if open_dbs := dbs_with_open_transactions():\n            raise _UnexpectedOpenTransaction(open_dbs=open_dbs)\n\n        return_value = func(*args, **kwargs)\n\n        if open_dbs := dbs_with_open_transactions():\n            # Clean up first, otherwise we may see errors later that will mask this one.\n            # This can only happen if the function manually opens a transaction,\n            # so we need to manually roll it back and close it.\n            for db_alias in open_dbs:\n                django_transaction.rollback(using=db_alias)\n                django_transaction.set_autocommit(True, using=db_alias)\n            raise _UnexpectedDanglingTransaction(open_dbs=open_dbs)\n\n        return return_value\n\n    return wrapper\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.run_after_commit","title":"run_after_commit","text":"<pre><code>run_after_commit(callback: Callable[[], object], *, using: str | None = None) -&gt; None\n</code></pre> <p>Register a callback to be called after the current transaction is committed.</p> <p>If the current transaction is rolled back, the callback will not be called. By default, an error will be raised if there is no transaction open. The transaction opened by tests is ignored for this purpose.</p> <p>Note that Django's <code>on_commit</code> has a <code>robust</code> parameter, which allows a callback to fail silently. Kraken has a convention to \"not allow code to fail silently\" so this behaviour is not available from this function.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>def run_after_commit(\n    callback: Callable[[], object],\n    *,\n    using: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Register a callback to be called after the current transaction is committed.\n\n    If the current transaction is rolled back, the callback will not be called.\n    By default, an error will be raised if there is no transaction open.\n    The transaction opened by tests is ignored for this purpose.\n\n    Note that Django's `on_commit` has a `robust` parameter, which allows a callback to fail silently.\n    Kraken has a convention to \"not allow code to fail silently\"\n    so this behaviour is not available from this function.\n    \"\"\"\n    if using is None:\n        using = django_db.DEFAULT_DB_ALIAS\n\n    # See Note [After-commit callbacks require a transaction]\n    needs_transaction = getattr(\n        settings, \"SUBATOMIC_AFTER_COMMIT_NEEDS_TRANSACTION\", True\n    )\n    only_in_testcase_transaction = _innermost_atomic_block_wraps_testcase(using=using)\n\n    # Fail if a transaction is required, but none exists.\n    # Ignore test-suite transactions when checking for a transaction.\n    # See Note [After-commit callbacks require a transaction]\n    if needs_transaction and not in_transaction(using=using):\n        raise _MissingRequiredTransaction(database=using)\n\n    if (\n        # See Note [Running after-commit callbacks in tests]\n        getattr(settings, \"SUBATOMIC_RUN_AFTER_COMMIT_CALLBACKS_IN_TESTS\", True)\n        and only_in_testcase_transaction\n    ):\n        callback()\n    else:\n        django_transaction.on_commit(callback, using=using)\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.in_transaction","title":"in_transaction","text":"<pre><code>in_transaction(*, using: str | None = None) -&gt; bool\n</code></pre> <p>Return <code>True</code> if the database connection has a transaction active.</p> <p>A transaction is active if the connection is no longer in autocommit mode.</p> <p>So that code doesn't need to handle how testcase transactions work, testcase transactions are not considered a transaction.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>def in_transaction(*, using: str | None = None) -&gt; bool:\n    \"\"\"\n    Return `True` if the database connection has a transaction active.\n\n    A transaction is active if the connection is no longer in autocommit mode.\n\n    So that code doesn't need to handle how testcase transactions work,\n    testcase transactions are not considered a transaction.\n    \"\"\"\n    if using is None:\n        using = django_db.DEFAULT_DB_ALIAS\n\n    connection = django_db.connections[using]\n    if connection.connection is None:\n        # If there is no database connection, we can't be in a transaction.\n        # We need to check this before checking for an open transaction,\n        # because `get_autocommit()` would open a database connection\n        # which we might not use and would consume resources unnecessarily.\n        return False\n\n    in_transaction = not django_transaction.get_autocommit(using=using)\n    if not in_transaction:\n        return False\n\n    only_in_testcase_transaction = _innermost_atomic_block_wraps_testcase(using=using)\n\n    # To make this as clear as possible I've spelled out the boolean logic here,\n    # and have told ruff to ignore that this could have been simply:\n    #\n    #     return not only_in_testcase_transaction\n    if only_in_testcase_transaction:  # noqa: SIM103\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.dbs_with_open_transactions","title":"dbs_with_open_transactions","text":"<pre><code>dbs_with_open_transactions() -&gt; frozenset[str]\n</code></pre> <p>Get the names of databases with open transactions.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>def dbs_with_open_transactions() -&gt; frozenset[str]:\n    \"\"\"\n    Get the names of databases with open transactions.\n    \"\"\"\n    dbs_with_open_transaction = set()\n    # Note: django_db.connections is a special class which implements __iter__,\n    # and should not be confused with a list or dict.\n    for db_alias in django_db.connections:\n        if in_transaction(using=db_alias):\n            dbs_with_open_transaction.add(db_alias)\n\n    return frozenset(dbs_with_open_transaction)\n</code></pre>"},{"location":"reference/django_subatomic/test/","title":"test","text":""},{"location":"reference/django_subatomic/test/#django_subatomic.test","title":"django_subatomic.test","text":""},{"location":"reference/django_subatomic/test/#django_subatomic.test.part_of_a_transaction","title":"part_of_a_transaction","text":"<pre><code>part_of_a_transaction(using: str | None = None) -&gt; Generator[None]\n</code></pre> <p>Allow calling <code>transaction_required</code> code without an explicit transaction.</p> <p>This is useful for directly testing code marked with <code>db.transaction_required()</code> without going through other code which is responsible for managing a transaction.</p> <p>This works by entering a new \"atomic\" block, so that the inner-most \"atomic\" isn't the one created by the test-suite.</p> <p>In \"transaction testcases\" this will create a transaction, but if you're writing a transaction testcase, you probably want to manage transactions more explicitly than by calling this.</p> <p>Note that this does not handle after-commit callback simulation. If you need that, consider using <code>django_subatomic.db.transaction</code> instead.</p> <p>See Note [_MissingRequiredTransaction in tests]</p> Source code in <code>django_subatomic/test.py</code> <pre><code>@contextlib.contextmanager\ndef part_of_a_transaction(using: str | None = None) -&gt; Generator[None]:\n    \"\"\"\n    Allow calling `transaction_required` code without an explicit transaction.\n\n    This is useful for directly testing code marked with `db.transaction_required()`\n    without going through other code which is responsible for managing a transaction.\n\n    This works by entering a new \"atomic\" block, so that the inner-most \"atomic\"\n    isn't the one created by the test-suite.\n\n    In \"transaction testcases\" this will create a transaction, but if you're writing\n    a transaction testcase, you probably want to manage transactions more explicitly\n    than by calling this.\n\n    Note that this does not handle after-commit callback simulation. If you need that,\n    consider using `django_subatomic.db.transaction` instead.\n\n    See Note [_MissingRequiredTransaction in tests]\n    \"\"\"\n    with transaction.atomic(using=using):\n        yield\n</code></pre>"}]}