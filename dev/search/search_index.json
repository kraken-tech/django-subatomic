{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Subatomic docs","text":""},{"location":"transactions-savepoints-and-atomic/","title":"Transactions and savepoints","text":"<p>When using Django Subatomic, it helps to know the difference between transactions and savepoints.</p>"},{"location":"transactions-savepoints-and-atomic/#transactions","title":"Transactions","text":"<p>Transactions allow multiple database changes to be made atomically. Inserts, updates (etc) made within a transaction are grouped together and \"committed\" (i.e. made visible outside of the transaction) all at once. If the transaction fails, no changes are committed.</p> <p>In SQL terms, a transaction starts with <code>BEGIN</code> and is committed with <code>COMMIT</code>. A transaction can be ended without committing using <code>ROLLBACK</code>.</p> <p>When using Django Subatomic, transactions are created with <code>transaction</code>, which can be used as both a decorator and a context manager.</p> <p>Note</p> <p>SQL does not support nested transactions, so nesting is not supported by <code>transaction</code>. It acts like Django's <code>atomic</code> with <code>durable=True</code></p> <p>See Atomic code for code which requires a transaction, but doesn't require partial rollback.</p> <p>See Savepoints for recovering from failure and continuing within a transaction.</p> <p>Warning</p> <p>Working inside a transaction may not isolate you from changes made outside the transaction. For more info see Transaction Isolation in PostgreSQL's docs.</p>"},{"location":"transactions-savepoints-and-atomic/#savepoints","title":"Savepoints","text":"<p>A savepoint is a mark inside a transaction that allows all commands after it to be rolled back, restoring the transaction state to what it was at the time of the savepoint.</p> <p>Savepoints are generally used to allow a transaction to recover from failure (such as a database constraint violation) so that work can continue within the same transaction.</p> <p>In SQL terms, a savepoint is created with <code>SAVEPOINT &lt;name&gt;</code>. It is rolled back with <code>ROLLBACK TO &lt;name&gt;</code> and discarded with <code>RELEASE SAVEPOINT &lt;name&gt;</code>.</p> <p>Subatomic creates savepoints using <code>savepoint</code>. This is a context manager, and cannot be used as a decorator.</p> <p>Tip</p> <p>Declare savepoints beside the logic which handles the roll-back behaviour. This makes it clear that the savepoint is required, and prevents needless savepoints.</p>"},{"location":"transactions-savepoints-and-atomic/#atomic-code","title":"Atomic code","text":"<p>Sometimes code needs to make multiple database changes atomically in a place that should not be responsible for managing a transactions.</p> <p>Decorate this code with <code>@transaction_required</code> to make it raise an exception when someone tries to run it without first opening a transaction.</p> <p>Tip</p> <p>Where possible, use <code>transaction_required</code> as a decorator.</p> <p>This form is preferred because it fails earlier, and presents a clearer requirement to programmers.</p> <p>You can still use <code>transaction_required</code> as a context manager though. This might be useful in code where you cannot know the required database (such as when the database name is passed in as a function parameter).</p> <p>Warning</p> <p>When testing code which uses <code>transaction_required</code>, you might see <code>_MissingRequiredTransaction</code> even though tests are run in a transaction by default.</p> <p>While unintuitive, this is deliberate. It prevents tests from passing when they neglect to create a transaction.</p> <p>If you are seeing this error when testing high-level code such as a view then you have probably forgotten to open a transaction.</p> <p>The trade-off is that lower-level tests will see this error too. If you're testing <code>transaction_required</code> code directly, and you're sure that the code shouldn't be responsible for opening a transaction, use the <code>part_of_a_transaction</code> decorator/context-manager to get things working. This will not run after-commit hooks. If you'd like those to run, create a transaction instead.</p> <p>When \"create-a-transaction-if-one-doesn't-already-exist\" behaviour is required, the <code>transaction_if_not_already</code> function will provide it. This approach hints that transactional behaviour is not well-defined: the code will do different things in different contexts, which makes it hard to know what to expect from it.</p>"},{"location":"why/","title":"Django's Atomic","text":"<p>This doc will discuss the behaviours available through Django's <code>atomic</code> and the outcomes people are usually trying to achieve with it. It goes on to outline some pitfalls that can result from using <code>atomic</code> and how Subatomic avoids them.</p> <p>Django's <code>atomic</code> ensures database changes are committed together-or-not-at-all. It creates a savepoint or a transaction depending on two factors:</p> <ul> <li>The arguments passed to it (<code>durable=</code> and <code>savepoint=</code>).</li> <li>If a database transaction is already open.</li> </ul>"},{"location":"why/#behaviours","title":"Behaviours","text":"<p>The Behaviours which <code>atomic</code> exhibits are:</p> <code>savepoint=</code> <code>durable=False</code> (default) <code>durable=True</code> <code>True</code> (default) A. Begin a transaction if needed. Creates a savepoint if already in a transaction. B. Begin a transaction, or throw an error if one is already open. Never creates a savepoint. (The <code>savepoint=</code> flag is ignored.) <code>False</code> C. Begin a transaction if needed. Never creates a savepoint. Same as B."},{"location":"why/#outcomes","title":"Outcomes","text":"<p>When people use <code>atomic</code>, they're generally trying to achieve one of three Outcomes:</p> <ol> <li>to create a transaction    which will commit multiple changes atomically.</li> <li>to create a savepoint    so we can roll back to in order to continue with a transaction after failure.</li> <li>to indicate that changes should be committed atomically,    without needing to be specific about the scope of the transaction,    as long as there is one.</li> </ol>"},{"location":"why/#problems","title":"Problems","text":""},{"location":"why/#ambiguous-code","title":"Ambiguous code","text":"<p>Ideally, we should be able to look at a line of code and say what it will do.</p> <p>Because <code>atomic</code>'s behaviour depends on whether a transaction is already open, one must know the full call stack to know what any particular <code>atomic</code> will do. If it is called in multiple code paths, developers must know that it will do different database operations depending on who calls it.</p> <p>Subatomic avoids this issue by offering an unambiguous API (<code>transaction()</code>, <code>savepoint()</code>, etc).</p>"},{"location":"why/#transactions-without-context","title":"Transactions without context","text":"<p>Low-level code rarely has the context to know when a transaction should be committed. For example, it may know that its changes must happen atomically, but cannot know if it is part of a larger suite of changes managed by higher-level code which must also be committed together.</p> <p>When low-level code uses <code>atomic</code> to indicate that its changes should be atomic (Outcome 3), this can have one of two effects:</p> <ul> <li> <p>If the higher-level code has opened a transaction,   the lower-level code will create a savepoint it does not need.</p> </li> <li> <p>If the higher-level code has not opened a transaction,   the lower-level code will.   While this will achieve the atomicity it demands,   it fails to ensure that the larger suite of changes   is also atomic.</p> </li> </ul> <p>Django offers no APIs to indicate the creation of a savepoint (Outcome 2) or the need for atomicity (Outcome 3) that doesn't have the potential to create a transaction instead.</p> <p>A function decorated with Subatomic's <code>@transaction_required</code> will raise an error when called outside of a transaction, rather than run the risk of creating a transaction with the wrong scope.</p>"},{"location":"why/#savepoints-by-default","title":"Savepoints by default","text":"<p><code>atomic</code> defaults to Behaviour A which creates savepoints by default when there is already an open transaction.</p> <p>It's common to decorate functions with <code>atomic</code> to indicate that code should be atomic (Outcome 3), but neglect to pass <code>savepoint=False</code>. This results in more database queries than necessary.</p> <p>Subatomic's <code>@transaction_required</code> decorator gives developers an unambiguous alternative that will never open a savepoint.</p>"},{"location":"why/#savepoints-as-decorators","title":"Savepoints as decorators","text":"<p>Savepoints are intrinsically linked to error handling. They are only required when we need a safe place to continue from after a failure within a transaction. Ideally then, the logic for catching the failure and continuing a transaction should be adjacent to the logic which creates the savepoint.</p> <p>When we use <code>atomic</code> as a decorator, we separate the savepoint creation from the error handling logic. The decorated function will not be within a <code>try:...except...:</code>.</p> <p>This lack of cohesion can make it difficult to know where continuing after rolling back a savepoint is intended to be handled, or even if it is handled at all. This is compounded by the fact that because <code>atomic</code>'s API is ambiguous, it can be hard to know the intended Outcome.</p> <p>To encourage putting rollback logic alongside savepoint creation, Subatomic's <code>savepoint</code> cannot be used as a decorator.</p>"},{"location":"why/#tests-without-after-commit-callbacks","title":"Tests without after-commit callbacks","text":"<p>To avoid leaking state between tests, Django's <code>TestCase</code> runs each test within a transaction which gets rolled back at the end of the test. As a result, <code>atomic</code> blocks encountered during the test will not create transactions so no after-commit callbacks will be run.</p> <p>Even if Django wanted to simulate after-commit callbacks in tests, it has no way to know which Outcome was intended when it encounters an <code>atomic</code> block. It might be running a high-level test where a transaction is intended and callbacks should be run, or a low-level test where an open transaction is assumed and callbacks should not be run.</p> <p>Without Subatomic, developers must either manually run after-commit callbacks in tests, which is prone to error and omission, or run the test using <code>TransactionTestCase</code>, which can be very slow.</p> <p>Subatomic's <code>transaction()</code> function will run after-commit callbacks automatically in tests so that code behaves the same in tests as it does in production.</p>"},{"location":"reference/settings/","title":"Settings","text":"<p>Django Subatomic has some custom Django settings to help with the process of adopting it in existing projects.</p>"},{"location":"reference/settings/#subatomic_after_commit_needs_transaction","title":"<code>SUBATOMIC_AFTER_COMMIT_NEEDS_TRANSACTION</code>","text":"<p>(default: <code>True</code>)</p> <p>When this setting is <code>True</code>, <code>run_after_commit</code> will raise an exception if no transaction is open.</p> <p>This setting is intended to help projects transition to this strict behaviour by getting it working in tests before enabling it in production.</p>"},{"location":"reference/settings/#subatomic_run_after_commit_callbacks_in_tests","title":"<code>SUBATOMIC_RUN_AFTER_COMMIT_CALLBACKS_IN_TESTS</code>","text":"<p>(default: <code>True</code>)</p> <p>When this setting is <code>True</code>, after-commit callbacks will be run in tests when a <code>transaction</code> (or <code>transaction_if_not_already</code>) context is exited.</p> <p>This setting is intended to help projects progressively enable after-commit callbacks in tests by using <code>override_settings</code> on a per-test basis.</p>"},{"location":"reference/django_subatomic/","title":"django_subatomic","text":""},{"location":"reference/django_subatomic/#django_subatomic","title":"django_subatomic","text":""},{"location":"reference/django_subatomic/db/","title":"db","text":""},{"location":"reference/django_subatomic/db/#django_subatomic.db","title":"django_subatomic.db","text":""},{"location":"reference/django_subatomic/db/#django_subatomic.db.transaction","title":"transaction","text":"<pre><code>transaction(*, using: str | None = None) -&gt; Generator[None]\n</code></pre> <p>Create a database transaction.</p> <p>Nested calls are not allowed because SQL does not support nested transactions. Consider this like Django's <code>atomic(durable=True)</code>, but with added after-commit callback support in tests.</p> <p>This wraps Django's 'atomic' function.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if we call this from inside another existing transaction.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>@contextlib.contextmanager\ndef transaction(*, using: str | None = None) -&gt; Generator[None]:\n    \"\"\"\n    Create a database transaction.\n\n    Nested calls are not allowed because SQL does not support nested transactions.\n    Consider this like Django's `atomic(durable=True)`, but with added after-commit callback support in tests.\n\n    This wraps Django's 'atomic' function.\n\n    Raises:\n        RuntimeError: if we call this from inside another existing transaction.\n    \"\"\"\n    # Note that `savepoint=False` is not required here because\n    # the `savepoint` flag is ignored when `durable` is `True`.\n    with (\n        _execute_on_commit_callbacks_in_tests(using),\n        django_transaction.atomic(using=using, durable=True),\n    ):\n        yield\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.transaction_if_not_already","title":"transaction_if_not_already","text":"<pre><code>transaction_if_not_already(*, using: str | None = None) -&gt; Generator[None]\n</code></pre> <p>Create a transaction if one isn't already open.</p> <p>Use of this hints at code which lacks control over the state it's called in.</p> <p>Suggested alternatives:</p> <ul> <li> <p>In functions which should not control transactions, use <code>transaction_required</code>.   This ensures they are handled by the caller.</p> </li> <li> <p>In functions which can unambiguously control transactions, use <code>transaction</code>.</p> </li> </ul> Source code in <code>django_subatomic/db.py</code> <pre><code>@contextlib.contextmanager\ndef transaction_if_not_already(*, using: str | None = None) -&gt; Generator[None]:\n    \"\"\"\n    Create a transaction if one isn't already open.\n\n    Use of this hints at code which lacks control over the state it's called in.\n\n    Suggested alternatives:\n\n    - In functions which should not control transactions, use `transaction_required`.\n      This ensures they are handled by the caller.\n\n    - In functions which can unambiguously control transactions, use `transaction`.\n    \"\"\"\n    # If the innermost atomic block is from a test case, we should create a SAVEPOINT here.\n    # This allows for a rollback when an exception propagates out of this block, and so\n    # better simulates a production transaction behaviour in tests.\n    savepoint = _innermost_atomic_block_wraps_testcase(using=using)\n\n    with (\n        _execute_on_commit_callbacks_in_tests(using),\n        django_transaction.atomic(using=using, savepoint=savepoint),\n    ):\n        yield\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.savepoint","title":"savepoint","text":"<pre><code>savepoint(*, using: str | None = None) -&gt; Generator[None]\n</code></pre> <p>Create a database savepoint.</p> <p>Must be called inside an active transaction.</p> <p>Tips:</p> <ul> <li>You should only create a savepoint if you may roll back to it before   continuing with your transaction. If your intention is to ensure that   your code is committed atomically, consider using <code>transaction_required</code>   instead.</li> <li>We believe savepoint rollback should be handled where the savepoint is created.   That locality is not possible with a decorator, so this function   deliberately does not work as one.</li> </ul> <p>Raises:</p> Type Description <code>_MissingRequiredTransaction</code> <p>if we are not in a transaction See Note [_MissingRequiredTransaction in tests]</p> Source code in <code>django_subatomic/db.py</code> <pre><code>@_utils.contextmanager\ndef savepoint(*, using: str | None = None) -&gt; Generator[None]:\n    \"\"\"\n    Create a database savepoint.\n\n    Must be called inside an active transaction.\n\n    Tips:\n\n    - You should only create a savepoint if you may roll back to it before\n      continuing with your transaction. If your intention is to ensure that\n      your code is committed atomically, consider using `transaction_required`\n      instead.\n    - We believe savepoint rollback should be handled where the savepoint is created.\n      That locality is not possible with a decorator, so this function\n      deliberately does not work as one.\n\n    Raises:\n        _MissingRequiredTransaction: if we are not in a transaction\n            See Note [_MissingRequiredTransaction in tests]\n    \"\"\"\n    with (\n        transaction_required(using=using),\n        django_transaction.atomic(using=using),\n    ):\n        yield\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.transaction_required","title":"transaction_required","text":"<pre><code>transaction_required(*, using: str | None = None) -&gt; Generator[None]\n</code></pre> <p>Make sure that code is always executed in a transaction.</p> <p>Can be used as a decorator or a context manager.</p> <p>We ignore test-suite transactions when checking for a transaction because we don't want to run the risk of allowing code to pass tests but fail in production.</p> <p>See Note [_MissingRequiredTransaction in tests]</p> <p>Raises:</p> Type Description <code>_MissingRequiredTransaction</code> <p>if we are not in a transaction.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>@contextlib.contextmanager\ndef transaction_required(*, using: str | None = None) -&gt; Generator[None]:\n    \"\"\"\n    Make sure that code is always executed in a transaction.\n\n    Can be used as a decorator or a context manager.\n\n    We ignore test-suite transactions when checking for a transaction\n    because we don't want to run the risk of allowing code to pass tests\n    but fail in production.\n\n    See Note [_MissingRequiredTransaction in tests]\n\n    Raises:\n        _MissingRequiredTransaction: if we are not in a transaction.\n    \"\"\"\n    if using is None:\n        using = django_db.DEFAULT_DB_ALIAS\n\n    if not in_transaction(using=using):\n        raise _MissingRequiredTransaction(database=using)\n    yield\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.durable","title":"durable","text":"<pre><code>durable[**P, R](func: Callable[P, R]) -&gt; Callable[P, R]\n</code></pre> <p>Enforce durability with this decorator.</p> <p>\"Durability\" means that the function's work cannot be rolled back after it completes, and is not to be confused with \"atomicity\" (which is about ensuring that the function either completes all its work or none of it).</p> <p>We enforce this by ensuring that the function is not called within a transaction, and that no transaction is left open when the function completes.</p> <p>Raises:</p> Type Description <code>_UnexpectedOpenTransaction</code> <p>if a transaction is already open when this is called.</p> <code>_UnexpectedDanglingTransaction</code> <p>if a transaction remains open after the decorated function exits. Before raising this exeption, we roll back and end the transaction.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>def durable[**P, R](func: Callable[P, R]) -&gt; Callable[P, R]:\n    \"\"\"\n    Enforce durability with this decorator.\n\n    \"Durability\" means that the function's work cannot be rolled back after it completes,\n    and is not to be confused with \"atomicity\" (which is about ensuring that the function\n    either completes all its work or none of it).\n\n    We enforce this by ensuring that the function is not called within a transaction,\n    and that no transaction is left open when the function completes.\n\n    Raises:\n        _UnexpectedOpenTransaction: if a transaction is already open when this is called.\n        _UnexpectedDanglingTransaction: if a transaction remains open after the decorated\n            function exits. Before raising this exeption, we roll back and end the\n            transaction.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        if open_dbs := dbs_with_open_transactions():\n            raise _UnexpectedOpenTransaction(open_dbs=open_dbs)\n\n        try:\n            return func(*args, **kwargs)\n        finally:\n            if open_dbs := dbs_with_open_transactions():\n                # Clean up first, otherwise we may see errors later that will mask this one.\n                # This can only happen if the function manually opens a transaction,\n                # so we need to manually roll it back and close it.\n                for db_alias in open_dbs:\n                    django_transaction.rollback(using=db_alias)\n                    django_transaction.set_autocommit(True, using=db_alias)\n                raise _UnexpectedDanglingTransaction(open_dbs=open_dbs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.run_after_commit","title":"run_after_commit","text":"<pre><code>run_after_commit(callback: Callable[[], object], *, using: str | None = None) -&gt; None\n</code></pre> <p>Register a callback to be called after the current transaction is committed.</p> <p>If the current transaction is rolled back, the callback will not be called. By default, an error will be raised if there is no transaction open. The transaction opened by tests is ignored for this purpose.</p> <p>Note that Django's <code>on_commit</code> has a <code>robust</code> parameter, which allows a callback to fail silently. Kraken has a convention to \"not allow code to fail silently\" so this behaviour is not available from this function.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>def run_after_commit(\n    callback: Callable[[], object],\n    *,\n    using: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Register a callback to be called after the current transaction is committed.\n\n    If the current transaction is rolled back, the callback will not be called.\n    By default, an error will be raised if there is no transaction open.\n    The transaction opened by tests is ignored for this purpose.\n\n    Note that Django's `on_commit` has a `robust` parameter, which allows a callback to fail silently.\n    Kraken has a convention to \"not allow code to fail silently\"\n    so this behaviour is not available from this function.\n    \"\"\"\n    if using is None:\n        using = django_db.DEFAULT_DB_ALIAS\n\n    # See Note [After-commit callbacks require a transaction]\n    needs_transaction = getattr(\n        settings, \"SUBATOMIC_AFTER_COMMIT_NEEDS_TRANSACTION\", True\n    )\n    only_in_testcase_transaction = _innermost_atomic_block_wraps_testcase(using=using)\n\n    # Fail if a transaction is required, but none exists.\n    # Ignore test-suite transactions when checking for a transaction.\n    # See Note [After-commit callbacks require a transaction]\n    if needs_transaction and not in_transaction(using=using):\n        raise _MissingRequiredTransaction(database=using)\n\n    if (\n        # See Note [Running after-commit callbacks in tests]\n        getattr(settings, \"SUBATOMIC_RUN_AFTER_COMMIT_CALLBACKS_IN_TESTS\", True)\n        and only_in_testcase_transaction\n    ):\n        callback()\n    else:\n        django_transaction.on_commit(callback, using=using)\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.in_transaction","title":"in_transaction","text":"<pre><code>in_transaction(*, using: str | None = None) -&gt; bool\n</code></pre> <p>Return <code>True</code> if the database connection has a transaction active.</p> <p>A transaction is active if the connection is no longer in autocommit mode.</p> <p>So that code doesn't need to handle how testcase transactions work, testcase transactions are not considered a transaction.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>def in_transaction(*, using: str | None = None) -&gt; bool:\n    \"\"\"\n    Return `True` if the database connection has a transaction active.\n\n    A transaction is active if the connection is no longer in autocommit mode.\n\n    So that code doesn't need to handle how testcase transactions work,\n    testcase transactions are not considered a transaction.\n    \"\"\"\n    if using is None:\n        using = django_db.DEFAULT_DB_ALIAS\n\n    connection = django_db.connections[using]\n    if connection.connection is None:\n        # If there is no database connection, we can't be in a transaction.\n        # We need to check this before checking for an open transaction,\n        # because `get_autocommit()` would open a database connection\n        # which we might not use and would consume resources unnecessarily.\n        return False\n\n    in_transaction = not django_transaction.get_autocommit(using=using)\n    if not in_transaction:\n        return False\n\n    only_in_testcase_transaction = _innermost_atomic_block_wraps_testcase(using=using)\n\n    # To make this as clear as possible I've spelled out the boolean logic here,\n    # and have told ruff to ignore that this could have been simply:\n    #\n    #     return not only_in_testcase_transaction\n    if only_in_testcase_transaction:  # noqa: SIM103\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/django_subatomic/db/#django_subatomic.db.dbs_with_open_transactions","title":"dbs_with_open_transactions","text":"<pre><code>dbs_with_open_transactions() -&gt; frozenset[str]\n</code></pre> <p>Get the names of databases with open transactions.</p> Source code in <code>django_subatomic/db.py</code> <pre><code>def dbs_with_open_transactions() -&gt; frozenset[str]:\n    \"\"\"\n    Get the names of databases with open transactions.\n    \"\"\"\n    dbs_with_open_transaction = set()\n    # Note: django_db.connections is a special class which implements __iter__,\n    # and should not be confused with a list or dict.\n    for db_alias in django_db.connections:\n        if in_transaction(using=db_alias):\n            dbs_with_open_transaction.add(db_alias)\n\n    return frozenset(dbs_with_open_transaction)\n</code></pre>"},{"location":"reference/django_subatomic/test/","title":"test","text":""},{"location":"reference/django_subatomic/test/#django_subatomic.test","title":"django_subatomic.test","text":""},{"location":"reference/django_subatomic/test/#django_subatomic.test.part_of_a_transaction","title":"part_of_a_transaction","text":"<pre><code>part_of_a_transaction(using: str | None = None) -&gt; Generator[None]\n</code></pre> <p>Allow calling <code>transaction_required</code> code without an explicit transaction.</p> <p>This is useful for directly testing code marked with <code>db.transaction_required()</code> without going through other code which is responsible for managing a transaction.</p> <p>This works by entering a new \"atomic\" block, so that the inner-most \"atomic\" isn't the one created by the test-suite.</p> <p>In \"transaction testcases\" this will create a transaction, but if you're writing a transaction testcase, you probably want to manage transactions more explicitly than by calling this.</p> <p>Note that this does not handle after-commit callback simulation. If you need that, consider using <code>django_subatomic.db.transaction</code> instead.</p> <p>See Note [_MissingRequiredTransaction in tests]</p> Source code in <code>django_subatomic/test.py</code> <pre><code>@contextlib.contextmanager\ndef part_of_a_transaction(using: str | None = None) -&gt; Generator[None]:\n    \"\"\"\n    Allow calling `transaction_required` code without an explicit transaction.\n\n    This is useful for directly testing code marked with `db.transaction_required()`\n    without going through other code which is responsible for managing a transaction.\n\n    This works by entering a new \"atomic\" block, so that the inner-most \"atomic\"\n    isn't the one created by the test-suite.\n\n    In \"transaction testcases\" this will create a transaction, but if you're writing\n    a transaction testcase, you probably want to manage transactions more explicitly\n    than by calling this.\n\n    Note that this does not handle after-commit callback simulation. If you need that,\n    consider using `django_subatomic.db.transaction` instead.\n\n    See Note [_MissingRequiredTransaction in tests]\n    \"\"\"\n    with transaction.atomic(using=using):\n        yield\n</code></pre>"}]}